◎オブジェクトと関数◎
オブジェクトの「値」の部分には、関数を用いることもできます。
下図のようにプロパティの値として関数を記述します。また、その関数を呼び出すには、「定数名.プロパティ名()」とします。プロパティ名の後ろの()を忘れないようにしましょう。
よく使う書き方なので、この機会に覚えておきましょう。
具体例では、オブジェクトの「greet」プロパティに対応する値に関数（アロー関数）を用いています。
そして、「user.greet()」とすることで関数が実行され、コンソールに表示されています。
    ＜例＞
      const 定数名 = {
        プロパティ名：（） => {
          処理
        }
      };
      定数名.プロパティ名();
　　      
 　　＜具体例＞
      const user = {
        name: "にんじゃわんこ";
        greet: () => {
          cons0le.log("こんにちは！");
        }
      };
      user.greet();
       
       //出力結果：　こんにちは！
       
◎オブジェクトを量産する◎
Webサービスなどでは、先ほど作成したようなオブジェクトをいくつも扱っています。例えばProgateのようなログインが必要なサービスでは、ユーザー（利用者）に関するデータ（オブジェクト）を用いています。
これらのデータは毎回ゼロから作成していたら大変です。ここからは、似たようなデータを効率よく生成する方法を学習していきましょう。

◎オブジェクトの設計図◎
効率よくオブジェクトを作成していくための方法として、最初に「設計図」を用意する方法があります。
例えばユーザーのデータをいくつも作成する場合、最初に「ユーザーを生成するための設計図」を用意し、
その設計図をもとにユーザーのデータを生成していく、といったことができます。

◎クラス◎
前のスライドで説明した「設計図」のことをJavaScriptでは「クラス」と呼びます。
「class クラス名」とすることで新しくクラスを用意できます。なお、クラス名は基本的に大文字から始めるようにしましょう。

◎インスタンスの生成◎
オブジェクトを生成するための設計図を用意できたので、その設計図から実際にオブジェクトを生成してみましょう。クラスからオブジェクトを生成するには、「new クラス名()」とします。
クラスから生成したオブジェクトは特別にインスタンスと呼びます。また、AnimalクラスのインスタンスをAnimalインスタンスと呼びます。

　＜例＞
 　 class Animal {
   
    }
    const animal = new Animal();
    
◎コンストラクタ◎
今はまだクラスに何も処理を追加していないため、白紙の設計図のような状態です。
クラスにはコンストラクタと呼ばれる機能が用意されています。コンストラクタはインスタンスを生成するときに実行したい処理や設定を追加するための機能です。
まず、図のように、クラスの中括弧 { } 内に「constructor() { }」と記述します。

　　＜例＞
  　　class Animal {
       //ここに設計図の中身を追加する
     }
  　　
    
     class Animal {
       constructor() {
       }
     }
     
◎コンストラクタの処理◎
図のように、コンストラクタの中には処理を記述することができます。
ここに書いた処理はインスタンスが生成された直後に実行されます。
大切なのは、インスタンスごとに毎回実行されるということです。以下の図では2回「new Animal()」としているので、その度にコンストラクタ内の処理が実行されます。

　　＜例＞
     class Animal {
       constructor() {
         console.log("こんにちは！");
       }
     ｝
     const animal1 = new Animal();
     const animal2 = new Animal();
     
       //出力結果：　こんにちは！
  　　　　　　　　　 こんにちは！
  
◎プロパティと値を追加する◎
コンストラクタの中で、生成したインスタンスに関する情報を追加してみましょう。
コンストラクタの中で「this.プロパティ = 値」とすることで、生成されたインスタンスにプロパティと値を追加することができます。

◎インスタンスごとに値を変える◎
コンストラクタ内の処理を追加したことで、生成されるインスタンスの初期設定をすることができました。しかし、以下のコードでは生成されるインスタンスはすべて「レオ」「3」のように同じ値になっています。
インスタンスごとに自由に値を変える方法を次のスライドから学習して行きましょう。

      ＜例＞
        class Animal {
          constructor() {
            this.name ="レオ";
            this.age = 3;
          }
        }
  
◎コンストラクタの引数◎
コンストラクタでは、引数を受け取ることが可能です。
「constructor」の後の括弧「( )」内に引数名を記述することで、その引数をコンストラクタの処理内で使用できます。
コンストラクタに引数として値を渡すには、「new クラス名()」の括弧「( )」内に値を追加します。
以下の図では、文字列「"レオ"」という値が引数として渡され、コンストラクタ内では「name」として使うことができます。

      ＜例＞
        class Animal {
          constructor(name, age) {
            this.name = name;
            this.age = age;
          }
        }
        const animal = new Animal("レオ", 3);
        
        
◎メソッドとは◎
ここからクラスの重要な機能の1つである「メソッド」について学習していきましょう。
メソッドとはそのインスタンスの「動作」のようなものです。
「名前」や「年齢」などの情報はプロパティで追加したのに対して、メソッドは「挨拶をする」「値を計算する」などの処理のまとまりを表します。

◎メソッドの定義◎
メソッドはクラスの中で定義します。「メソッド名() { }」とすることでメソッドは定義できます。
メソッドは関数と似たようなもので、中括弧「{ }」の中にそのメソッドで行いたい処理を記述します。
メソッドは、そのクラスから生成したインスタンスに対して呼び出します。
具体的には、「インスタンス.メソッド名()」とすることでそのメソッドを呼び出し、処理を実行することができます。

      ＜例＞
       class クラス名 {
          constructor() {
             :
             :
          }
          インスタンス.メソッド名（） {
            //行いたい処理
          }
        }
        
◎メソッド内で値を使う◎
では次に、「name」の値を用いて「名前は〇〇です」と出力するメソッドを作成してみましょう。
メソッド内でインスタンスの値を使用するには、「this」という特殊な値を用いて、「this.プロパティ名」とします。

◎メソッド内でメソッドを使う◎
メソッド内で他のメソッドを呼び出すことも可能です。
メソッド内で「this.メソッド名()」とすることで、同じクラスの他のメソッドを使うことができます。

        ＜例＞
         class Animal {
          constructor(name, age) {
            this.name = name;
            this.age = age;
          }

          greet() {
            console.log("こんにちは");
          }

          info() {
            // greetメソッドを呼び出す
            this.greet();
            console.log(`名前は${this.name}です`);
            console.log(`${this.age}歳です`);
          }
        }
        const animal = new Animal("レオ", 3);
        animal.info();

◎継承とは◎
「継承」とは、すでにあるクラスをもとに、新しくクラスを作成する方法のことです。
例えば「Animalクラス」から「Dogクラス」を継承すると、「Animalクラス」の全ての機能を引き継いで、「Dogクラス」を作成することができます。

◎継承の書き方◎
継承を用いてクラスを作成するには「extends」を用います。
「Animalクラス」を継承して「Dogクラス」を作成するには、図のように「class Dog extends Animal」と書きます。
また、継承では元となるクラスを親クラス（今回はAnimalクラス）、新しく作成するクラスを子クラス（今回はDogクラス）と呼びます。

◎使えるメソッド◎
「Dogクラス」は「Animalクラス」のすべての機能を引き継いでいます。
そのため、「Dogクラス」内にはまだ何もメソッドは定義されていませんが、「Animalクラス」に定義されている「infoメソッド」などを使用することができます。

        ＜例＞
         class Animal {
          constructor(name, age) {
            this.name = name;
            this.age = age;
          }

          greet() {
            console.log("こんにちは");
          }

          info() {
            this.greet();
            console.log(`名前は${this.name}です`);
            console.log(`${this.age}歳です`);
          }
        }

        class Dog extends Animal {
        }

        // 定数dogにDogクラスのインスタンスを代入する
        const dog = new Dog("レオ", 4);

        // dogに対してinfoメソッドを呼び出す
        dog.info();

◎独自のメソッド◎
継承して作成したクラスにも、これまでと同じようにメソッドを追加することができます。
今回は犬の年齢を人間の年齢に換算する「getHumanAge」メソッドを用意してみましょう。

◎メソッドの戻り値◎
メソッドでは、関数と同じように戻り値を用いることができます。
以下の図では、「getHumanAge」メソッドの戻り値を、「humanAge」という定数に代入しています。

◎子クラスのメソッド◎
子クラスで定義した独自のメソッドは、親クラスから呼び出すことはできません。
以下のように、AnimalクラスのインスタンスからgetHumanAgeメソッドを呼び出すとエラーが発生してしまいます。

◎同名のメソッド◎
継承したクラスは、親クラスのメソッドと子クラスのメソッドの両方が使用できることがわかったかと思います。
では以下の図のように、Animalクラス（親クラス）にすでにあるメソッドと同じ名前のメソッドをDogクラス（子クラス）に定義すると、どちらのメソッドが呼び出されるでしょうか？

◎オーバーライド◎
親クラスと同じ名前のメソッドを子クラスに定義すると、子クラスのメソッドが優先して使用されます。
これは、子クラスのメソッドが親クラスのメソッドを上書きしていることから、オーバーライドと呼ばれます。

◎コンストラクタのオーバーライド◎
メソッドと同じように、コンストラクタもオーバーライドすることができます。例えば、子クラスにプロパティを追加したい場合などに用います。
ただし、コンストラクタをオーバーライドする際は1行目に「super()」と記述する必要があります。
子クラスのコンストラクタ内の「super()」では、その部分で親クラスのコンストラクタを呼び出しています。
そのため、親クラスのコンストラクタが引数を受け取る場合には、「super」の後ろの丸括弧「( )」に引数を渡す必要があります。
今回は親クラスのコンストラクタを呼び出したあとに、犬の種類を表す「breed」プロパティを追加しています。

