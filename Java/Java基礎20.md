◎継承を学ぶ
　・クラスの内容を引き継ぐ
 　　コードの重複は保守性（修正・改善のしやすさ）を下げるため、できるだけ避けるべきです。
    オブジェクト指向では、あるクラスの内容を他のクラスが「引き継ぐ」ことができます。
    ※重複部分をまとめられそうであればまとめて重複部分をなくすようにすること！！
    （例、CarクラスとBicycleクラスで記述が重複していたら、Vehicleクラス（乗り物）に定義し、そのクラスをCarクラスとBicycleクラスが引き継げるようにする）
    
  ・継承
  　既存のクラスのフィールドやメソッドを別のクラスに引き継ぐ機能を「継承」といいます。
  　さらに継承してできる新しいクラスには独自のフィールドやメソッドを追加してカスタマイズすることも可能です。
　　継承されるクラスを「スーパークラス」、継承してできる新しいクラスを「サブクラス」と呼びます。
  
  ・継承の方法
  　継承を用いて新しくサブクラスを定義するときは、「extends」を用いて「class サブクラス名 extends スーパークラス名」としてクラスを定義します。
　　extendsは「拡張する」という意味です。継承は、スーパークラスを元に、機能を拡張したサブクラスを作るための機能なのです。
  
  　＜例、スーパークラス＞
  　　　class スーパークラス名　{
          //　処理；
       }
     
    ＜例、サブクラス＞
    　　class サブクラス名 extends スーパークラス名 {
         //　処理
        }
      　　　　　⬇
    　・スーパークラスのメソッドを呼び出す
     　サブクラスはスーパークラスのフィールドとメソッドを引き継いでいます。
      　よって、サブクラス自体にはまだ何も定義されていませんが、サブクラスのインスタンスに対して、スーパークラスのインスタンスメソッドを呼び出すことが可能です。
       
       ＜例、スーパークラスから継承されたメソッドを呼び出せる＞
          
          class Taxi extends Car {
            // 何も定義されていないが、
            // スーパークラスからprintInfoメソッドを継承している
          }

          class Car {
            public void printInfo() {
              System.out.println("車です");
            }
          }

          class Main {
            public static void main (String[] args) {
              Taxi taxi = new Taxi();
              taxi.printInfo();  // 結果: 「車です」
            }
          }

　・サブクラスのフィールドとメソッド
 　　サブクラスには、スーパークラスにない独自のフィールドやメソッドを追加し、カスタマイズすることができます。
   
  ・メソッド呼び出しの注意点
 　　サブクラスのインスタンスは、自身のクラスに定義したメソッドだけでなく、スーパークラスのメソッドも呼び出すことができます。
　　 一方スーパークラスのインスタンスはサブクラスのメソッドを呼びだすことはできません。
    クラスの継承は一方的なため、スーパークラスはサブクラスのメソッドを見つけることはできずエラーが発生してしまいます。
    
　・メソッド呼び出しの仕組み
 　　サブクラスのインスタンスに対して、メソッドを呼ぶ際には図のようにメソッドが呼ばれます。
　　 呼び出したメソッドが、サブクラスに定義されていればサブクラスから、定義されていなければスーパークラスから呼び出されます。
   
◎オーバーライド   
  ・メソッドのカスタマイズ
　　　スーパークラスから継承しているメソッドの処理を、特定のサブクラスでカスタマイズしたいという場合・・・
   　スーパークラスから継承したメソッドと同名のメソッドをサブクラスに定義することで、スーパークラスのメソッドの内容を上書きすることができます。
     これを「オーバーライド」といいます。
  ・オーバーライドの仕組み
  　　サブクラスのインスタンスに対してメソッドを呼び出すと、まずサブクラスの中でそのメソッドを探し、持っていればそのメソッドを呼び出します。
　　　つまりスーパークラスと同名のメソッドがサブクラスにあれば、それが実行されるので、結果的にメソッドの内容が上書きされたようになります。

     ＜例、メソッドのオーバーライド（上書き）＞
     　
        class Taxi extends Car {
          public void printInfo() {
            System.out.println("タクシーです");
          }
        }
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
        class Car {
          public void printInfo() {
            System.out.println("車です");
          }
        }
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
        class Main {
          public static void main (String[] args) {
            Taxi taxi = new Taxi();
            taxi.printInfo();  
          }
        }

　　　　　　　　　【出力結果：タクシーです】
         
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

　・スーパークラスのメソッドを呼ぶ
 　　「super.メソッド名()」とすると、サブクラスのインスタンスメソッドから、スーパークラスのインスタンスメソッドを呼び出すことができます。
   
   　＜例、スーパークラスのメソッドを呼び出す＞
    　　
      　class Taxi extends Car {
          public void printInfo() {
            super.printInfo();
            System.out.println("タクシーです");
          }
        }
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
        class Car {
          public void printInfo() {
            System.out.println("車です");
          }
        }
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
        class Main {
          public static void main (String[] args) {
            Taxi taxi = new Taxi();
            taxi.printInfo();  
          }
        }
        
          【出力結果: 車です、タクシーです】
        
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
        
        
　・サブクラスのコンストラクタ
 　　サブクラスでコンストラクタを定義するときには1つの決まりがあります。
   　それは「コンストラクタの先頭でスーパークラスのコンストラクタを呼びださなければならない」ということです。
    
  ・スーパークラスのコンストラクタ呼び出し
  　スーパークラスのコンストラクタを呼び出すには、super()を用います。

   ＜例、スーパークラスのメソッドを呼び出す＞
   
   　class Taxi extends Car {
      Taxi(String name) {
        super(name);
        System.out.println(name + "をタクシーにしました");
      }
    }
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
    class Car {
      Car(String name) {
        System.out.println(name + "を作ります");
      }
    }
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
    class Main {
      public static void main (String[] args) {
        Taxi taxi = new Taxi("フェラーリ");
      }
    }

　　【出力結果: フェラーリを作ります、フェラーリをタクシーにしました】

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

　・protected
 　　サブクラスのメソッドが、スーパークラスのprivateで定義しているフィールドにアクセスしようとすると制限が掛かりエラーとなるが、
   　「protected」を用いると、クラス内とサブクラスからのみアクセスを許すフィールドを作ることができます。
    こうすると、無事にスーパークラスのフィールドにアクセスすることが出来る。
    
  【アクセス権のまとめ】
  　「public」「protected」「private」の3つのアクセス権についておさらいしましょう。
  
    ・public: どこからでもアクセス可能
    ・protected: そのクラスと子クラス内からのみアクセス可能
    ・private: そのクラス内からのみアクセス可能
    
　・抽象メソッド
 　　処理が未定のメソッドを定義する方法があります。
    下図のようにメソッドの先頭にabstractをつけることで、抽象メソッドというメソッドを定義できます。抽象メソッドには中身の処理は書きません。
    abstractとは「抽象的な」という意味です。具体的な処理が決まっていない未完成のメソッドであるため、「抽象メソッド」と呼ばれます。
    
  ・メリットとポイント
   　抽象メソッドは、サブクラスがそのメソッドをオーバーライド（上書き）していなければエラーになります。
     ですので、サブクラスがそのメソッドをオーバーライドし、処理内容を定義することを強制できます。
     サブクラスに、あるメソッドを必ず持たせたいという場合は、スーパークラスに抽象メソッドとして定義しておくことが大事です。
     
  ・抽象クラス
   　抽象メソッドを1つでも持つクラスは、「抽象クラス」と呼ばれ、クラス名の前にabstractをつける必要があります。
     抽象クラスはインスタンスを生成できません。抽象メソッドという未完成のメソッドを持つクラスは、それもまた未完成です。
     そのような未完成のクラスからはインスタンスを生成できないような仕組みになっています。
     ＜例＞
   　　　abstract class Vehicle {
         :
         :
         abstract public void run(int distance);
        }
        
  ・クラス型のフィールド
  　　インスタンスフィールドにクラス型の変数を定義することで、フィールドにインスタンスを持つことが可能です。
    
  ・多態性
  　Carクラスをスーパークラス、Taxiクラスをサブクラスとする
   
    Taxiクラスのインスタンスは、Car型の変数に代入できる
   
   　Car car = new Taxi();
    
    Carクラスのインスタンスは、Taxi型の変数に代入できない（）
    
     Taxi taxi = new Car(); // エラー発生
     
     
